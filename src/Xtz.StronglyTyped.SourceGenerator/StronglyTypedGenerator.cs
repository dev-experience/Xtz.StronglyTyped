using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Xtz.StronglyTyped.SourceGenerator
{
    [Generator]
    public class StronglyTypedGenerator : IStronglyTypedGenerator
    {
        private readonly IDataExtractor _dataExtractor = new DataExtractor();

        private readonly List<string> _log = new();

        public void Initialize(GeneratorInitializationContext context)
        {
#if DEBUG_STRONGLY_TYPED_GENERATOR
//#if DEBUG
            if (!Debugger.IsAttached) Debugger.Launch();
#endif

            // Register a syntax receiver that will be created for each generation pass
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not SyntaxReceiver receiver) return;

            try
            {
                var now = DateTime.UtcNow;

                foreach (var declaration in receiver.Declarations)
                {
                    try
                    {
                        var semanticModel = context.Compilation.GetSemanticModel(declaration.TypeDeclarationSyntax.SyntaxTree, true);
                        if (_dataExtractor.BuildWorkItem(semanticModel, receiver, declaration, out var workItem))
                        {
                            var fileName = $"{workItem!.Namespace}.{workItem.TypeName}.cs";
                            var generatedSourceCode = GenerateSourceCode(workItem, now);
                            context.AddSource(fileName, SourceText.From(generatedSourceCode, Encoding.UTF8));
                        }
                    }
                    catch (Exception e)
                    {
                        if (!Debugger.IsAttached) Debugger.Launch();

                        _log.Add($"Method '{nameof(WriteTypeConverter)}.{nameof(Execute)}()' threw an exception '{e.Message}'.\nStack trace: {e.StackTrace}");
                    }
                }
            }
            catch (Exception e)
            {
                if (!Debugger.IsAttached) Debugger.Launch();

                _log.Add($"Method '{nameof(WriteTypeConverter)}.{nameof(Execute)}()' threw an exception '{e.Message}'.\nStack trace: {e.StackTrace}");
            }
            finally
            {
                context.AddSource("_1-receiver-log", BuildLogText(receiver.Log, "SYNTAX RECEIVER LOG"));
                context.AddSource("_2-data-extractor-log", BuildLogText(_dataExtractor.Log, "DATA EXTRACTOR LOG"));
                context.AddSource($"_3-generator-log", BuildLogText(_log, "GENERATOR LOG"));
            }
        }

        private string GenerateSourceCode(StronglyTypedWorkItem workItem, DateTime timestamp)
        {
            var writer = new CodeWriter();

            WriteBanner(writer, workItem, timestamp);

            writer.AppendLine();
            using (writer.BeginScope($"namespace {workItem.Namespace}"))
            {
                writer.AppendLine("using System.ComponentModel;");
                writer.AppendLine("using System.Text.Json.Serialization;");
                writer.AppendLine();

                WriteTypeConverter(writer, workItem);
                writer.AppendLine($"[JsonConverter(typeof(Xtz.StronglyTyped.TypeConverters.StronglyTypedJsonConverter<{workItem.Namespace}.{workItem.TypeName}>))]");

                switch (workItem.Kind)
                {
                    case WorkItemKind.Class:
                        WriteClass(writer, workItem);
                        break;
                    case WorkItemKind.Struct:
                        WriteStruct(writer, workItem);
                        break;
                    case WorkItemKind.Unknown:
                    default:
                        throw new CodeWriterException($"Not supported work item type '{workItem.Kind}'");
                }
            }

            var generatedSourceCode = writer.ToString();
            return generatedSourceCode;
        }

        private void WriteBanner(CodeWriter writer, StronglyTypedWorkItem workItem, DateTime timestamp)
        {
            var version = GetType().Assembly.GetName().Version;
            var assemblyVersion = $"{version.Major}.{version.Minor}.{version.Revision}.{version.Build}";

            writer.AppendLine(
                $@"//------------------------------------
// <auto-generated>
//     Type `{workItem.Namespace}.{workItem.TypeName}`
//
//     This code was generated by generator '{GetType().FullName}'
//     Assembly Version: {assemblyVersion}
//     Generation timestamp: {timestamp:s}Z
// </auto-generated>
//------------------------------------");
        }

        private void WriteTypeConverter(CodeWriter writer, StronglyTypedWorkItem workItem)
        {
            var valueType = workItem.InnerType;
            var typeConverter = valueType switch
            {
                var t when t == typeof(string) => $"[TypeConverter(typeof(Xtz.StronglyTyped.TypeConverters.StringTypeConverter<{workItem.TypeName}>))]",
                _ => $"[TypeConverter(typeof(Xtz.StronglyTyped.TypeConverters.TypeConverter<{workItem.TypeName}, {workItem.InnerType.FullName}>))]",
            };

            writer.AppendLine(typeConverter);
        }

        private void WriteClass(CodeWriter writer, StronglyTypedWorkItem workItem)
        {
            var baseType = !workItem.HasBaseType
                ? $" Xtz.StronglyTyped.StronglyTyped<{workItem.InnerType.FullName}>,"
                : String.Empty;

            var sealedStr = workItem.ExtraFeatures.IsAbstract
                ? string.Empty
                : " sealed";

            using (writer.BeginScope($"public{sealedStr} partial class {workItem.TypeName} :{baseType} System.IEquatable<{workItem.TypeName}>"))
            {
                writer.AppendLine($"public {workItem.TypeName}({workItem.InnerType.FullName} value)");
                writer.AppendLine("    : base(value)");
                using (writer.BeginScope())
                {
                }
                writer.AppendLine();

                TryWriteCustomConstructor(writer, workItem);

                WriteEquatableEquals(writer, workItem);
                writer.AppendLine();

                WriteExplicitOperatorToInnerType(writer, workItem);
                writer.AppendLine();

                WriteImplicitOperatorToStrongType(writer, workItem);
            }
        }

        private void TryWriteCustomConstructor(CodeWriter writer, StronglyTypedWorkItem workItem)
        {
            if (workItem.InnerType == typeof(Guid))
            {
                writer.AppendLine($"public {workItem.TypeName}()");
                writer.AppendLine("    : base(System.Guid.NewGuid())");
                using (writer.BeginScope())
                {
                }
                writer.AppendLine();
                return;
            }

            if (!workItem.ExtraFeatures.HasStringConstructor)
            {
                TryWriteStringConstructor(writer, workItem);
            }
        }

        private void TryWriteStringConstructor(CodeWriter writer, StronglyTypedWorkItem workItem)
        {
            var innerTypeStringConstructor = workItem.InnerType.GetConstructor(new[] { typeof(string)});
            if (innerTypeStringConstructor != null)
            {
                writer.AppendLine($"public {workItem.TypeName}(string value)");
                writer.AppendLine($"    : base(new {workItem.InnerType.FullName}(value))");
                using (writer.BeginScope())
                {
                }
                writer.AppendLine();
            }
        }

        private void WriteStruct(CodeWriter writer, StronglyTypedWorkItem workItem)
        {
            writer.AppendLine("[System.Diagnostics.DebuggerDisplay(\"[struct {GetType().Name,nq}] {Value}\")]");
            using (writer.BeginScope($"public readonly partial struct {workItem.TypeName} : Xtz.StronglyTyped.IStronglyTyped<{workItem.InnerType.FullName}>, System.IEquatable<{workItem.TypeName}>"))
            {
                writer.AppendLine($"public static readonly {workItem.TypeName} Default;");

                writer.AppendLine($"public {workItem.InnerType.FullName} Value {{ get; }}");
                writer.AppendLine();

                writer.AppendLine($"public {workItem.TypeName}({workItem.InnerType.FullName} value)");
                using (writer.BeginScope())
                {
                    writer.AppendLine("Value = value;");
                    //writer.AppendLine("ThrowIfInvalid(value);");
                }
                writer.AppendLine();

                WriteEquatableEquals(writer, workItem);
                writer.AppendLine();

                WriteToString(writer);
                writer.AppendLine();

                WriteStructEqualityMethods(writer, workItem);
                writer.AppendLine();

                WriteExplicitOperatorToInnerType(writer, workItem);
                writer.AppendLine();

                WriteImplicitOperatorToStrongType(writer, workItem);
            }
        }

        private void WriteStructEqualityMethods(CodeWriter writer, StronglyTypedWorkItem workItem)
        {
            using (writer.BeginScope("public override bool Equals(object obj)"))
            {
                writer.AppendLine($"return obj is {workItem.TypeName} other && Equals(other);");
            }
            writer.AppendLine();

            using (writer.BeginScope("public override int GetHashCode()"))
            {
                writer.AppendLine("return Value.GetHashCode();");
            }
        }

        private static void WriteEquatableEquals(CodeWriter writer, StronglyTypedWorkItem workItem)
        {
            using (writer.BeginScope($"public bool Equals({workItem.TypeName} other)"))
            {
                writer.AppendLine("if (ReferenceEquals(null, other)) return false;");
                writer.AppendLine("if (ReferenceEquals(this, other)) return true;");
                writer.AppendLine("return Equals(Value, other.Value);");
            }
        }

        private static void WriteToString(CodeWriter writer)
        {
            using (writer.BeginScope($"public override string ToString()"))
            {
                writer.AppendLine($"return Value.ToString();");
            }
        }

        private static void WriteExplicitOperatorToInnerType(CodeWriter writer, StronglyTypedWorkItem workItem)
        {
            using (writer.BeginScope(
                $"public static explicit operator {workItem.TypeName}({workItem.InnerType.FullName} value)"))
            {
                writer.AppendLine($"return new {workItem.TypeName}(value);");
            }
        }

        private static void WriteImplicitOperatorToStrongType(CodeWriter writer, StronglyTypedWorkItem workItem)
        {
            using (writer.BeginScope(
                $"public static implicit operator {workItem.InnerType.FullName}({workItem.TypeName} stronglyTyped)"))
            {
                if (workItem.Kind == WorkItemKind.Class)
                {
                    writer.AppendLine($"return stronglyTyped?.Value ?? default({workItem.InnerType.FullName});");
                }
                else
                {
                    writer.AppendLine($"return stronglyTyped.Value;");
                }
            }
        }

        private static SourceText BuildLogText(IReadOnlyCollection<string> log, string title)
        {
            var result = SourceText.From(
                string.Format(@"/*{0}{1}{0}{0}{2}*/",
                    Environment.NewLine,
                    title,
                    string.Join(Environment.NewLine, log)),
                Encoding.UTF8);
            return result;
        }
    }
}